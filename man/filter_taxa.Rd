% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/taxmap--docs.R
\name{filter_taxa}
\alias{filter_taxa}
\title{Filter taxa with a list of conditions}
\arguments{
\item{obj}{An object of class \code{\link[=taxmap]{taxmap()}}}

\item{...}{One or more filtering conditions. Each filtering condition can be
one of three things: \describe{ \item{\code{character}}{One or more taxon
IDs contained in \code{obj$edge_list$to}} \item{\code{integer}}{One or more
row indexes of \code{obj$edge_list}} \item{\code{logical}}{A
\code{TRUE}/\code{FALSE} vector of length equal to the number of rows in
\code{obj$edge_list}} } Any variable name that appears in
\code{obj$all_names()} can be used as if it was a vector on its own.}

\item{subtaxa}{(\code{logical} or \code{numeric} of length 1) If \code{TRUE}, include
subtaxa of taxa passing the filter. Positive numbers indicate the number of
ranks below the target taxa to return. \code{0} is equivalent to \code{FALSE}.
Negative numbers are equivalent to \code{TRUE}.}

\item{supertaxa}{(\code{logical}  or \code{numeric} of length 1) If \code{TRUE}, include
supertaxa of taxa passing the filter. Positive numbers indicate the number
of ranks above the target taxa to return. \code{0} is equivalent to \code{FALSE}.
Negative numbers are equivalent to \code{TRUE}.}

\item{taxonless}{(\code{logical}) If \code{TRUE}, include observations even
if the taxon they are assigned to is filtered out. Observations assigned to
removed taxa will be assigned to \code{NA}. This option can be either
simply \code{TRUE}/\code{FALSE}, meaning that all data sets will be treated
the same, or a logical vector can be supplied with names corresponding one
or more data sets in \code{obj$data}. For example, \code{c(abundance = TRUE, stats = FALSE)} would inlcude observations whose taxon was filtered
out in \code{obj$data$abundance}, but not in \code{obj$data$stats}. See the
\code{reassign_obs} option below for further complications.}

\item{reassign_obs}{(\code{logical} of length 1) If \code{TRUE}, observations
assigned to removed taxa will be reassigned to the closest supertaxon that
passed the filter. If there are no supertaxa of such an observation that
passed the filter, they will be filtered out if \code{taxonless} is
\code{TRUE}. This option can be either simply \code{TRUE}/\code{FALSE},
meaning that all data sets will be treated the same, or a logical vector
can be supplied with names corresponding one or more data sets in
\code{obj$data}. For example, \code{c(abundance = TRUE, stats = FALSE)}
would reassign observations in \code{obj$data$abundance}, but not in
\code{obj$data$stats}.}

\item{reassign_taxa}{(\code{logical} of length 1) If \code{TRUE}, subtaxa of
removed taxa will be reassigned to the closest supertaxon that passed the
filter. This is useful for removing intermediate levels of a taxonomy.}

\item{invert}{(\code{logical} of length 1) If \code{TRUE}, do NOT include the
selection. This is different than just replacing a \code{==} with a
\code{!=} because this option negates the selection after taking into
account the \code{subtaxa} and \code{supertaxa} options. This is useful for
removing a taxon and all its subtaxa for example.}
}
\value{
An object of type \code{\link[=taxmap]{taxmap()}}
}
\description{
Filter taxa in a \code{\link[=taxmap]{taxmap()}} object with a series of conditions. Any
variable name that appears in \code{obj$all_names()} can be used as if it was
a vector on its own. See \code{\link[dplyr:filter]{dplyr::filter()}} for the inspiration for
this function and more information. Calling the function using the
\code{obj$filter_taxa(...)} style edits "obj" in place, unlike most R
functions. However, calling the function using the \code{filter_taxa(obj, ...)} mitates R's traditional copy-on-modify semantics, so "obj" would not be
changed; instead a changed version would be returned, like most R functions.
\preformatted{ obj$filter_taxa(..., subtaxa = FALSE, supertaxa = FALSE,
taxonless = FALSE, reassign_obs = TRUE, reassign_taxa = TRUE, invert = FALSE)
filter_taxa(obj, ...)}
}
\examples{
# Filter by index
filter_taxa(ex_taxmap, 1:3)

# Filter by taxon ID
filter_taxa(ex_taxmap, c("1", "2", "3"))

# Fiter by TRUE/FALSE
filter_taxa(ex_taxmap, taxon_names == "Plantae", subtaxa = TRUE)

# Filter by an observation characteristic
dangerous_taxa <- sapply(ex_taxmap$obs("info"),
                         function(i) any(ex_taxmap$data$info$dangerous[i]))
filter_taxa(ex_taxmap, dangerous_taxa)

# Include supertaxa
filter_taxa(ex_taxmap, 12, supertaxa = TRUE)
filter_taxa(ex_taxmap, 12, supertaxa = 2)

# Include subtaxa
filter_taxa(ex_taxmap, 1, subtaxa = TRUE)
filter_taxa(ex_taxmap, 1, subtaxa = 2)

# Remove rows in data corresponding to removed taxa
filter_taxa(ex_taxmap, 2, taxonless = c(info = FALSE))

# Remove a taxon and it subtaxa
filter_taxa(ex_taxmap, 1, subtaxa = TRUE, invert = TRUE)

}
\seealso{
Other dplyr-like functions: \code{\link{arrange_obs}},
  \code{\link{arrange_taxa}}, \code{\link{filter_obs}},
  \code{\link{mutate_obs}}, \code{\link{sample_frac_obs}},
  \code{\link{sample_frac_taxa}},
  \code{\link{sample_n_obs}}, \code{\link{sample_n_taxa}},
  \code{\link{select_obs}}, \code{\link{transmute_obs}}
}
