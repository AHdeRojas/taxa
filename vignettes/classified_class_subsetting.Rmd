---
title: "Subsetting taxonomic data"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Subsetting taxonomic data}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(knitr)
opts_chunk$set(dev='svg', fig.width = 7, fig.height = 7)
```


## Install metacoder for data and plotting

```{r, eval = FALSE}
devtools::install_github("grunwaldlab/metacoder") # do this before trying to knit
```

```{r}
library(magrittr)
library(metacoder)
library(taxa)
```


## Pepare data

```{r}
file_path <- system.file("extdata", "unite_general_release.fasta", package = "metacoder")
sequences <- ape::read.FASTA(file_path)
data <- extract_taxonomy(names(sequences),
                         regex = "^(.*)\\|(.*)\\|(.*)\\|.*\\|(.*)$",
                         key = c(name = "item_info", seq_id = "item_info",
                                 other_id = "item_info", "class_name"),
                         database = "none")
```

## Acessing taxon data

Note how the `item_count` column is calculated each time it is needed. 
This is because the number of items per taxon can change when taxa are subsetted.

```{r}
head(taxon_data(data))
```


## Acessing item data

```{r}
head(item_data(data))
```


## Subsetting and plotting

I already made a `plot` method for `classified` in `metacoder` that calls `metacoder::plot_taxonomy`.
I also added some non-standard argument evaluation for the subsetting and plotting methods to save users some typing.
Columns in `classified_object$taxon_data` can be refereed to by name alone.

```{r}
plot(data, 
     vertex_size = item_count,
     vertex_color = item_count,
     vertex_label = name)
```

Note how this: 

```{r}
subset(data, name == "Ascomycota") %>%
  plot(vertex_size = item_count,
       vertex_color = item_count,
       vertex_label = name)
```

... is the same as this:

```{r}
data_subset <- subset(data, data$taxon_data$name == "Ascomycota")
plot(data_subset,
     vertex_size = taxon_data(data_subset, "item_count"),
     vertex_color = taxon_data(data_subset, "item_count"),
     vertex_label = data_subset$taxon_data$name)
```

```{r}
subset(data, item_count < 200) %>%
  plot(vertex_size = item_count,
       vertex_color = item_count,
       vertex_label = name,
       tree_label = name,
       layout = "fruchterman-reingold")
```


You can also choose wether the parents and children of taxa are preserved.

```{r}
subset(data, item_count > 5, subtaxa = FALSE) %>%
  plot(vertex_size = item_count,
       vertex_color = item_count,
       vertex_label = name)
```

However, it is still not working right as you might expect. 
I think this is because, when a child taxon is eliminated, its items are not transferred to the parent taxon.
This is why some taxa in the above two plots have `0` items.
Their children all together had > 5 items, but each child had < 5 items. 
I think the solution is to transfer the items of eliminated children to their non-eliminated parents, but I need to look into this more.


```{r}
data_subset <- subset(data, data$taxon_data$name == "Agaricales", supertaxa = TRUE)
plot(data_subset,
     vertex_size = taxon_data(data_subset, "item_count"),
     vertex_color = taxon_data(data_subset, "item_count"),
     vertex_label = data_subset$taxon_data$name)
```


## Combining multiple `classified` objects

```{r}
part_a <- subset(data, name == "Agaricales")
part_b <- subset(data, name == "Helotiales")
sum(part_a, part_b) %>%
  plot(vertex_size = item_count,
       vertex_color = item_count,
       vertex_label = name,
       tree_label = name,
       layout = "fruchterman-reingold")
```

